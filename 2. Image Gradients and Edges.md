# Computational Vision: Image Gradients and Edges

## 1. Introduction to Image Filtering

Image filtering involves computing a function of the local neighborhood for each pixel. Common purposes include:
- Image enhancement (e.g., denoising, resizing).
- Information extraction (e.g., texture, edges).
- Pattern detection (e.g., feature matching).

## 2. Edge Detection

### Objective
The goal of edge detection is to map an image from a 2D pixel array to a set of curves, line segments, or contours. Edges typically represent:
- Depth discontinuities (object boundaries).
- Changes in surface orientation (shape).
- Cast shadows.
- Reflectance changes (texture or appearance).

### Derivatives and Edges
An edge represents a rapid change in the image intensity function, often corresponding to extrema in the first derivative:
- **First derivative:** Identifies rapid changes in intensity.
  
### Image Gradient
The image gradient is a vector indicating the direction of most rapid intensity change:

$\nabla I = \left( \frac{\partial I}{\partial x}, \frac{\partial I}{\partial y} \right)$

- Gradient magnitude: 

$\| \nabla I \| = \sqrt{ \left( \frac{\partial I}{\partial x} \right)^2 + \left( \frac{\partial I}{\partial y} \right)^2 }$

- Gradient direction:

$\theta = \text{atan2}\left(\frac{\partial I}{\partial y}, \frac{\partial I}{\partial x}\right)$

## 3. Discrete Operators for Edge Detection

### First Derivatives (Finite Differences)
First derivatives are approximated using finite differences. For example, the partial derivatives with respect to x and y:

$\frac{\partial I}{\partial x} \approx I(i, j+1) - I(i, j)$

$\frac{\partial I}{\partial y} \approx I(i+1, j) - I(i, j)$

These can be implemented as convolution filters.

### Sobel and Prewitt Operators
These operators compute finite differences while giving more weight to pixels near the center of the filter. 
- **Sobel operator (x-direction):**

$\text{Sobel}_x = \begin{bmatrix} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \end{bmatrix}$

- **Prewitt operator (x-direction):**

$\text{Prewitt}_x = \begin{bmatrix} -1 & 0 & 1 \\ -1 & 0 & 1 \\ -1 & 0 & 1 \end{bmatrix}$

The y-direction filters are the transposed versions of the above.

## 4. Second Derivatives

Second derivatives can highlight intensity changes by focusing on the rate of change of the gradient. The second derivative of the image can be approximated using finite differences.

- **Laplacian operator:** Computes the sum of second derivatives with respect to x and y:

$\nabla^2 I = \frac{\partial^2 I}{\partial x^2} + \frac{\partial^2 I}{\partial y^2}$

For discrete data, this is implemented with the Laplacian mask:

$\text{Laplacian} = \begin{bmatrix} 0 & 1 & 0 \\ 1 & -4 & 1 \\ 0 & 1 & 0 \end{bmatrix}$

## 5. Gaussian Smoothing and Derivatives

To reduce the effect of noise on edge detection, Gaussian smoothing is commonly applied. The Gaussian filter smooths the image by averaging pixel values in a local neighborhood:

$G(x, y) = \frac{1}{2\pi\sigma^2} \exp \left( -\frac{x^2 + y^2}{2\sigma^2} \right)$

The derivative of a Gaussian filter can be used for edge detection (known as the **Derivative of Gaussian** (DoG)).

- **Derivative of Gaussian:**

$I \ast (G \ast d) = (I \ast G) \ast d$

where $\ast$ denotes convolution, and $d$ is a derivative filter.

## 6. Laplacian of Gaussian (LoG)

The **Laplacian of Gaussian (LoG)** combines Gaussian smoothing with the Laplacian operator. It is used to detect edges by finding zero-crossings in the second derivative:
- **LoG operator:**

$\nabla^2 G = \frac{\partial^2 G}{\partial x^2} + \frac{\partial^2 G}{\partial y^2}$

## 7. Canny Edge Detector

The Canny edge detector is a multi-step algorithm that detects edges robustly:
1. **Smoothing:** Apply a Gaussian filter to reduce noise.
2. **Gradient computation:** Compute the magnitude and direction of the gradient using derivative filters.
3. **Non-maximum suppression:** Thin the edges by retaining only local maxima in the gradient direction.
4. **Hysteresis thresholding:** Two thresholds are used (low and high). Strong edges (above the high threshold) are preserved, and weak edges (above the low threshold) are retained if connected to strong edges.

## 8. Effects of Scale (Ïƒ)

The choice of Gaussian filter scale ($\sigma$) affects edge detection:
- Larger $\sigma$: Detects larger, more prominent edges.
- Smaller $\sigma$: Detects finer details.

## 9. Summary of Edge Detectors

- **Sobel & Prewitt:** Fast, but sensitive to noise.
- **Laplacian & LoG:** Better at closed contours and scale selection.
- **Canny:** Combines smoothing, edge enhancement, and thresholding for continuous and thin edges.

## 10. Relation to CNNs

Edge detection principles, like convolution with learned filters, form the foundation of modern convolutional neural networks (CNNs). The activation maps in CNNs capture similar features, like edges, corners, and textures.

## 11. Final Remarks

Different edge detection methods have various trade-offs, such as speed, robustness, and ability to handle noise. Understanding these can help in selecting the appropriate method depending on the task.
