# Computational Vision: Image Gradients and Edges

## 1. Introduction to Image Filtering

Image filtering involves computing a function of the local neighborhood for each pixel. Common purposes include:
- Image enhancement (e.g., denoising, resizing).
- Information extraction (e.g., texture, edges).
- Pattern detection (e.g., feature matching).

### Types of Filters
1. **Linear filters**: Operate by convolving the image with a kernel (e.g., Gaussian blur, Sobel filter).
2. **Non-linear filters**: Apply more complex operations (e.g., median filter, bilateral filter).

## 2. Edge Detection

### Objective
The goal of edge detection is to map an image from a 2D pixel array to a set of curves, line segments, or contours. Edges typically represent:
- Depth discontinuities (object boundaries).
- Changes in surface orientation (shape).
- Cast shadows.
- Reflectance changes (texture or appearance).

### Derivatives and Edges
An edge represents a rapid change in the image intensity function, often corresponding to extrema in the first derivative:
- **First derivative:** Identifies rapid changes in intensity.
- **Second derivative:** Locates the precise position of edges (zero-crossings).

### Image Gradient
The image gradient is a vector indicating the direction of most rapid intensity change:

$\nabla I = \left( \frac{\partial I}{\partial x}, \frac{\partial I}{\partial y} \right)$

- Gradient magnitude: 

$\| \nabla I \| = \sqrt{ \left( \frac{\partial I}{\partial x} \right)^2 + \left( \frac{\partial I}{\partial y} \right)^2 }$

- Gradient direction:

$\theta = \text{atan2}\left(\frac{\partial I}{\partial y}, \frac{\partial I}{\partial x}\right)$

## 3. Discrete Operators for Edge Detection

### First Derivatives (Finite Differences)
First derivatives are approximated using finite differences. For example, the partial derivatives with respect to x and y:

$\frac{\partial I}{\partial x} \approx I(i, j+1) - I(i, j)$

$\frac{\partial I}{\partial y} \approx I(i+1, j) - I(i, j)$

These can be implemented as convolution filters.

### Sobel and Prewitt Operators
These operators compute finite differences while giving more weight to pixels near the center of the filter. 
- **Sobel operator (x-direction):**

$\text{Sobel}_x = \begin{bmatrix} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \end{bmatrix}$

- **Prewitt operator (x-direction):**

$\text{Prewitt}_x = \begin{bmatrix} -1 & 0 & 1 \\ -1 & 0 & 1 \\ -1 & 0 & 1 \end{bmatrix}$

The y-direction filters are the transposed versions of the above.

### Comparison of Sobel and Prewitt
- Sobel gives more weight to central pixels, making it slightly more robust to noise.
- Prewitt provides a better approximation of the gradient magnitude but is more sensitive to noise.

## 4. Second Derivatives

Second derivatives can highlight intensity changes by focusing on the rate of change of the gradient. The second derivative of the image can be approximated using finite differences.

- **Laplacian operator:** Computes the sum of second derivatives with respect to x and y:

$\nabla^2 I = \frac{\partial^2 I}{\partial x^2} + \frac{\partial^2 I}{\partial y^2}$

For discrete data, this is implemented with the Laplacian mask:

$\text{Laplacian} = \begin{bmatrix} 0 & 1 & 0 \\ 1 & -4 & 1 \\ 0 & 1 & 0 \end{bmatrix}$

### Properties of the Laplacian
- Isotropic (rotation-invariant)
- Highlights rapid intensity changes
- Sensitive to noise

## 5. Gaussian Smoothing and Derivatives

To reduce the effect of noise on edge detection, Gaussian smoothing is commonly applied. The Gaussian filter smooths the image by averaging pixel values in a local neighborhood:

$G(x, y) = \frac{1}{2\pi\sigma^2} \exp \left( -\frac{x^2 + y^2}{2\sigma^2} \right)$

The derivative of a Gaussian filter can be used for edge detection (known as the **Derivative of Gaussian** (DoG)).

- **Derivative of Gaussian:**

$I \ast (G \ast d) = (I \ast G) \ast d$

where $\ast$ denotes convolution, and $d$ is a derivative filter.

### Properties of Gaussian Smoothing
- Reduces noise
- Blurs edges
- Scale-space representation (varying $\sigma$)

## 6. Laplacian of Gaussian (LoG)

The **Laplacian of Gaussian (LoG)** combines Gaussian smoothing with the Laplacian operator. It is used to detect edges by finding zero-crossings in the second derivative:
- **LoG operator:**

$\nabla^2 G = \frac{\partial^2 G}{\partial x^2} + \frac{\partial^2 G}{\partial y^2}$

### Advantages of LoG
- Combines smoothing and edge detection
- Less sensitive to noise than Laplacian alone
- Detects edges and their orientations

## 7. Canny Edge Detector

The Canny edge detector is a multi-step algorithm that detects edges robustly:
1. **Smoothing:** Apply a Gaussian filter to reduce noise.
2. **Gradient computation:** Compute the magnitude and direction of the gradient using derivative filters.
3. **Non-maximum suppression:** Thin the edges by retaining only local maxima in the gradient direction.
4. **Hysteresis thresholding:** Two thresholds are used (low and high). Strong edges (above the high threshold) are preserved, and weak edges (above the low threshold) are retained if connected to strong edges.

### Advantages of Canny Edge Detector
- Good detection: Low error rate
- Good localization: Edges detected close to true edges
- Minimal response: Only one detector response per edge

## 8. Effects of Scale (Ïƒ)

The choice of Gaussian filter scale ($\sigma$) affects edge detection:
- Larger $\sigma$: Detects larger, more prominent edges.
- Smaller $\sigma$: Detects finer details.

### Scale-Space Theory
- Analyzing images at multiple scales reveals different features
- Helps in understanding the hierarchical structure of images

## 9. Summary of Edge Detectors

- **Sobel & Prewitt:** Fast, but sensitive to noise.
- **Laplacian & LoG:** Better at closed contours and scale selection.
- **Canny:** Combines smoothing, edge enhancement, and thresholding for continuous and thin edges.

## 10. Relation to CNNs

Edge detection principles, like convolution with learned filters, form the foundation of modern convolutional neural networks (CNNs). The activation maps in CNNs capture similar features, like edges, corners, and textures.

### CNN and Edge Detection Similarities
- Convolutional layers in CNNs learn filters that often resemble edge detectors
- Early layers in CNNs typically detect low-level features like edges and corners
- Deeper layers combine these low-level features to detect more complex patterns

## 11. Applications of Edge Detection

Edge detection is fundamental in many computer vision tasks:
- Object detection and recognition
- Image segmentation
- Feature extraction
- Medical image analysis
- Autonomous driving (lane detection, obstacle detection)

## 12. Final Remarks

Different edge detection methods have various trade-offs, such as speed, robustness, and ability to handle noise. Understanding these can help in selecting the appropriate method depending on the task.

### Considerations for Choosing an Edge Detection Method
- Computational efficiency required
- Noise level in the images
- Type of edges to be detected (fine details vs. major boundaries)
- Downstream tasks (e.g., segmentation, object detection)

## 13. Future Directions

- Machine learning approaches to edge detection
- Combining traditional edge detection with deep learning techniques
- Edge detection in 3D data (point clouds, volumetric data)
- Real-time edge detection for video processing and augmented reality
